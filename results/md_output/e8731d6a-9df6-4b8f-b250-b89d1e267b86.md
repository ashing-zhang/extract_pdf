A note on Beckett-Gray codes and the
6102 guA 52  ]OC.htam[  2v10060.8061:viXra
relationship of Gray codes to data structures
Mark Cooke
Network Appliance
495 East Java Drive
Sunnyvale, CA 94089. U.S.A.
Mark.Cooke@netapp.com
Chris North
Tutte Institute for Mathematics and Computer Science
1929 Ogilvie Road
Ottawa ON K1J 0B9, Canada
cjnorth@gmail.com
Megan Dewar, Brett Stevens
School of Mathematics and Statistics
Carleton University
1125 Colonel By Drive
Ottawa ON K1S 5B6, Canada
megan.dewar@gmail.com
brett@math.carleton.ca
September 23, 2018
Abstract
In this paper we introduce a natural mathematical structure derived
from Samuel Beckett’s play “Quad”. We call this structure a binary
Beckett-Gray code. We enumerate all codes for n ≤ 6 and give exam-
ples for n = 7,8. Beckett-Gray codes can be realized as successive states
of a queue data structure. We show that the binary reflected Gray code
can be realized as successive states of two stack data structures.
1 Introduction
Samuel Beckett’s play “Quad” consists of a series of arrivals and departures
of four characters resulting in their appearance on stage together in different
combinations throughout the play. At regular intervals exactly one character
will enter the stage or exactly one character will exit the stage. There are no
apparent constraints on which off-stage character is allowed to enter, however,
when a character exits, it is always the character who has been on stage the
longest. The play ends as one character’s exit is about to reproduce the play’s
1

starting configuration. Beckett’s text explicitly notes that every possible non-
empty subset of characters appear on stage together at least once but admits
that these subsets do not appear a uniform number of times [1].
If each subset of appeared precisely once, then the series of subsets – repre-
sented by length four binary words – would form a cyclic Gray code with n = 4.
Gray codes of binary n-bit words are equivalent to Hamilton paths and cycles in
the n-dimensional hypercube [14]. The additional exit constraint is equivalent
to only permitting a 1 in bit position p to change to a 0 if, of those positions
containing a 1, position p has been so longest. In other words, this 1 has the
longest current run. We will call a Gray code with this additional property a
Beckett-Gray code. For all but the shortest codes, we will display a Gray code by
its transition sequence; the list of bit positions at which each change takes place.
We number the bit positions from the right, starting from zero. While the liter-
ary use of Beckett-Gray codes has been explored [13], here we investigate these
objects mathematically. We will discuss their isomorphisms and enumerate all
Beckett-Gray codes for n ≤ 6 and give examples for n = 7,8. We finish by
discussing the compatibility of Gray codes – not just Beckett-Gray codes – with
various data-structures. This work was completed over a decade ago and since
then other results regarding Beckett-Gray codes have been published. We feel
this note provides the necessary background to this work; for a more detailed
account of the history and searches see [5].
2 Preliminaries
The existence of a Beckett-Gray code is equivalent to being able to realize every
subset of an n-set exactly once as successive states of a queue, where queue
entries are the bit positions that are currently 1. In Table 1 we give an example
of a non-cyclic Beckett-Gray code and the corresponding queue states.
Code Queue
000 ∅
001 0
011 0,1
010 1
110 1,2
100 2
101 2,0
111 2,0,1
Table 1: A 3-bit non-cyclic binary Beckett-Gray code.
Two Gray codes are called isomorphic if one can be obtained from the other
by permuting bit positions, adding a fixed n-bit word to all words and/or re-
versing the list of words. Permuting bit positions preserves the Beckett-Gray
2

property, but addition of a non-zero word switches the role of 0 and 1 in at
least one position and may destroy the Beckett-Gray property. On the other
hand, given that the time reversal of a queue is still a queue, the reverse of a
Beckett-Gray code is also Beckett-Gray.
A Gray code is called self-isomorphic if there is a non-trivial isomorphism
that fixes the code. A Gray code is self-reverse if it can be obtained from
its reversal by any isomorphism. We show that no binary Gray code can be
isomorphic to its own reverse without adding a fixed binary word.
Theorem 2.1. No cyclic binary Gray code is self-reverse for n ≥ 3 without
adding a fixed word.
Proof. Assume we have a such a self-reverse code. Since the reversal is isomor-
phic, there exists a permutation of the bit positions, ρ, which is the isomorphism
between the code and its reverse. Note that ρ is order two and all its orbits are
of size 1 or 2. Let O ⊆ {1,2,...,n} be any non-empty union of orbits of ρ and
let w be the word that has a 1 only in bits from O. Since ρ(w ) = w , w
O O O O
n−1
must occur at position 2 in the code but this contradicts the fact that when
n ≥ 3, there is more than one choice for O.
If the addition of an n-bit binary word is permitted as an isomorphism, then
Frank Gray’s binary reflected Gray code is self-reverse for all n.
In the course of enumerating Beckett-Gray codes, we must be careful to
eliminate isomorphic codes. All codes listed in this paper will be given as the
lexicographically least transition sequence from their isomorphism class.
Donald Knuth included a description of Beckett-Gray codes in Pre-Fascicle
2a of his Vol 4 of The Art of Computer Programming and posed the problem of
finding a Beckett-Gray code for n = 8 [10]. This note presents the 2005 solution
to this question. In 2007, Dennis Wong and Joe Sawada independently enumer-
ated the Beckett-Gray codes for n = 6 using faster techniques and produced
almost 10,000 cyclic Beckett-Gray codes for n = 7 [12]. These results were part
of Wong’s M.Sc thesis [16].
3 Enumeration and existence
The unique binary Gray codes for 1 and 2-bits are both cyclic and are both
Beckett-Gray codes. There are no cyclic Beckett-Gray codes for n = 3 nor
n = 4, but there are one and four non-cyclic Beckett-Gray codes, respectively.
Their transition sequences are 0102101, 010213202313020, 010213212031321,
012301202301230,and 012301213210321. For n = 5 there are eight non-isomorphic
cyclic Beckett-Gray codes. These codes are given in Table 2. There are 116 non-
isomorphic non-cyclic 5-bit Beckett-Gray codes, available upon request. For
n = 6, there are 94,841 non-isomorphic cyclic Beckett-Gray codes. To give
some idea of the range of codes, the lexicographically first and last are
0102013120240312152430145052341304513534523514302514523405125415,
0123450123435432543125340134140503214541052401432501435032125032
3

01020132010432104342132340412304 01020312403024041232414013234013
01020314203024041234214103234103 01020314203240421034214130324103
01020341202343142320143201043104 01023412032403041230341012340124
01201321402314340232134021431041 01203041230314043210403202413241
Table 2: Transition sequences of the eight cyclic Beckett-Gray codes for n = 5.
There are 5,868,331 non-isomorphic non-cyclic 6-bit Beckett-Gray codes.
There exist cyclic Beckett-Gray codes for n = 7 and n = 8. For n = 7, the
lexicographically first cyclic Beckett-Gray code is
0123450106212343540616521234640561324201560323415051306451210626
4215606432150563641505646052563625410363410502350412342104320545.
A cyclic Beckett-Gray code for n = 8 is
0123456070121324356576071021353462670153741236256701731426206570
1342146560573102464537571020435376140736304642737035640271327505
4121027564150240365425013602541615604312576032572043157624321760
4520417516354767035647570625437242132624161523417514367143164314.
The enumeration was done using a depth first lexicographical search algo-
rithm. To obtain all codes for n = 6, the algorithm was parallelized and dis-
tributed over a small cluster of 2003 era computers. This search was confirmed
by being written two times independently and has also been verified by Wong
and Sawada [12]. We used Knuth’s method [11] to determine an estimate for
the size of the full back-tracking search tree for n = 7. The method was verified
for accuracy on the n = 5,6 cases. We conclude that the sizes of the trees for
19 44.7 102
n = 5,6 and 7 are on the order of 2 , 2 and 2 respectively. We suspect
that an exhaustive tree-based search for the n = 7 cyclic Beckett-Gray codes,
even with advances in computer hardware and the techniques of Sawada and
Wong [12], is infeasible. The method used to find cyclic Beckett-Gray codes for
n = 8 used simulated annealing to produce long, incomplete codes that satis-
fied the Beckett-Gray property. These were then fed as seeds to a deterministic
backtracking search. This is similar to the approach used in [3, 15].
4 Gray codes and data structures
The connection between Beckett-Gray codes and queues prompts the question
of whether other Gray codes can be realized as successive states of various data
structures. We have been able to show a nice result regarding Frank Gray’s
binary reflected Gray code [6, 9].
Theorem 4.1. The standard binary reflected Gray code can be realized as suc-
cessive states of a pair of stacks.
4

Proof. This can be proved by induction. The two stacks will be used to represent
the appearances of a 1 in even and odd bit positions, respectively. We show this
for small n in Table 3. Assume that n = k can be realized in two stacks, the
Gray code even stack odd stack Gray code even stack odd stack
00 ∅ ∅ 000 ∅ ∅
01 0 ∅ 001 0 ∅
11 0 1 011 0 1
10 ∅ 1 010 ∅ 1
110 2 1
111 20 1
101 20 ∅
100 2 ∅
Table 3: Binary reflected Gray codes realized as successive states of two stacks.
k
first using even indices and the second using odd indices. The first 2 words of
the (k + 1)-bit binary reflected Gray code are the same words as those of the
st
k-bit binary reflected Gray code with a 0 in the (k + 1) bit. Thus the first
half of the code is realizable in two stacks by the induction hypothesis. The last
word in this half of the code is all 0s except there is a 1 in bit position k − 1.
This corresponds to the stack with parity k − 1 containing just the element
k − 1 and the other stack being empty. The remaining half of the (k + 1)-bit
binary reflected Gray code is the first half in reverse order, with a 1 always in
bit position k. We simply push k onto the stack with parity k (which is empty)
and then notice that we can easily run the stack operations from the first half
in reverse as stack operations are time reversible.
We note that the stack data structure has been used in efficient generation
of many Gray codes, however, in these cases the state of the stack itself does
not represent the current element of the code [2].
5 Conclusion
Beckett-Gray codes have connections to other combinatorial orderings. For
example, they force the runs of 1s in the code to be relatively long and so are
related to some known Gray codes with long bit runs [7, 8]. Since the objects
in a Beckett-Gray code are realizable as the successive states of a queue, these
codes are similar to de Bruijn cycles and universal cycles [4], except that in the
case of Beckett-Gray codes, successive objects are close both in the Hamming
distance sense and in the queue state sense.
Small Beckett-Gray codes all exist, suggesting that the larger codes do too.
The goal is to find a recursive or direct construction for Beckett-Gray codes;
however, a non-constructive or probabilistic proof would be encouraging.
5

References
[1] Samuel Beckett. Collected Shorter Plays of Samuel Beckett. faber and
faber, London, 1984.
[2] James R. Bitner, Gideon Ehrlich, and Edward M. Reingold. Efficient gener-
ation of the binary reflected Gray code and its applications. Comm. ACM,
19(9):517–521, 1976.
[3] Bette Bultena and Frank Ruskey. Transition restricted Gray codes. Elec-
tron. J. Combin., 3(1):Research Paper 11, 11 pp. (electronic), 1996.
[4] F. Chung, P. Diaconis, and R. Graham. Universal cycles for combinatorial
structures. Discrete Math., 110:43–59, 1992.
[5] M. Cooke, C. North, M. Dewar, and B. Stevens. Beckett-Gray Codes.
ArXiv e-prints, August 2016, 1608.06001v1.
[6] E. N. Gilbert. Gray codes and paths on the n-cube. Bell System Tech. J,
37:815–826, 1958.
[7] L. Goddyn, G. M. Lawrence, and E. Nemeth. Gray codes with optimized
run lengths. Utilitas Mathematica, 34:179–192, 1988.
[8] Luis Goddyn and Pavol Gvozdjak. Binary Gray codes with long bit runs.
Electron. J. Combin., 10:Research Paper 27, 10 pp. (electronic), 2003.
[9] F. Gray. Pulse code communications. U.S. Patent 2632058, March 1953.
[10] Donald Knuth. Volume 4 of The Art of Computer Programming, Fascicle
2: Generating All Tuples and Permutations. Addison-Wesley, 2005.
[11] Donald E. Knuth. Estimating the efficiency of backtrack programs. Math.
Comp., 29:122–136, 1975. Collection of articles dedicated to Derrick Henry
Lehmer on the occasion of his seventieth birthday.
[12] J. Sawada and D.C-H. Wong. A fast algorithm to generate Beckett-Gray
codes. In Proceedings of EuroComb 2007, Electronic Notes in Discrete
Math., volume 29, pages 571–577, 2007.
[13] Brett Stevens. A Purgatorial Calculus: Beckett’s Mathematics in Quad,
chapter 12, pages 164–181. Wiley-Blackwel, 2010.
[14] Herbert S. Wilf. Combinatorial algorithms: an update, volume 55 of CBMS-
NSF Regional Conference Series in Applied Mathematics. Society for In-
dustrial and Applied Mathematics (SIAM), Philadelphia, PA, 1989.
[15] Elizabeth L. Wilmer and Michael D. Ernst. Graphs induced by Gray codes.
Discrete Math., 257(2-3):585–598, 2002.
[16] Dennis Chi-Him Wong. Fast algorithms to generate beckett-gray codes and
coil-in-the-box codes. Master’s thesis, University of Guelph, 2007.
6