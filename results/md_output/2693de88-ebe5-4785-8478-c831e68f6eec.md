Small, strongly typed, embeddable language. ## Examples
Hello world
1 let {print} = import "std.io"
2 let world = "world"
3 print(f"hello {world}!")
Async/await
1 let {print} = import "std.io"
2
3 let foo = fn()
4 print("foo started")
5 let bar_frame = async bar()
6 print("in foo")
7 let bar_res = await bar_frame
8 print("foo finished")
9 return bar_res
10
11 let bar = fn()
12 print("bar started")
13 suspend
14 print("bar resumed")
15 suspend
16 print("bar finished")
17 return 1
18
19
20 print("main started")
21 let foo_frame = async foo()
22 print("in main")
23 let res = await foo_frame
24 print("main finished:", res)
1 $ bog async.bog
2 main started
3 foo started
4 bar started
5 in foo
6 bar resumed
7 in main
8 bar finished
9 foo finished
10 main finished: 1
1

| 1 let {print} = import "std.io"   |
|:----------------------------------|
| 2 let world = "world"             |
| 3 print(f"hello {world}!")        |

| 1 let {print} = import "std.io"   |
|:----------------------------------|
| 2                                 |
| 3 let foo = fn()                  |
| 4 print("foo started")            |
| 5 let bar_frame = async bar()     |
| 6 print("in foo")                 |
| 7 let bar_res = await bar_frame   |
| 8 print("foo finished")           |
| 9 return bar_res                  |
| 10                                |
| 11 let bar = fn()                 |
| 12 print("bar started")           |
| 13 suspend                        |
| 14 print("bar resumed")           |
| 15 suspend                        |
| 16 print("bar finished")          |
| 17 return 1                       |
| 18                                |
| 19                                |
| 20 print("main started")          |
| 21 let foo_frame = async foo()    |
| 22 print("in main")               |
| 23 let res = await foo_frame      |
| 24 print("main finished:", res)   |

| 1 $ bog async.bog   |
|:--------------------|
| 2 main started      |
| 3 foo started       |
| 4 bar started       |
| 5 in foo            |
| 6 bar resumed       |
| 7 in main           |
| 8 bar finished      |
| 9 foo finished      |
| 10 main finished: 1 |

Calculator
1 let {input, print} = import "std.io"
2
3 try
4 let val1 = input("first argument: ") as num
5 let op = input("operation: ")
6 let val2 = input("second argument: ") as num
7
8 match op
9 "*" => print(val1 * val2)
10 "+" => print(val1 + val2)
11 "-" => print(val1 - val2)
12 "/" => print(val1 / val2)
13 "**" => print(val1 ** val2)
14 _ => print(f"unknown op: {op}")
15 catch
16 print("that's not a number")
Use command line arguments
1 # run with `path/to/bog path/here.bog arg1 arg2 "foo"`
2 let {print} = import "std.io"
3 print(import "args")
Loops
1 let mut sum = 0
2 for let c in "hellö wörld"
3 match c
4 "h" => sum += 1
5 "e" => sum += 2
6 "l" => sum += 3
7 "ö" => sum += 4
8 "w" => sum += 5
9 "d" => sum += 6
10
11 return sum # 31
1 let getSome = fn(val) if (val != 0) val - 1
2
3 let mut val = 10
4 while let newVal = getSome(val)
5 val = newVal
6 return val # 0
2

| 1 let {input, print} = import "std.io"         |
|:-----------------------------------------------|
| 2                                              |
| 3 try                                          |
| 4 let val1 = input("first argument: ") as num  |
| 5 let op = input("operation: ")                |
| 6 let val2 = input("second argument: ") as num |
| 7                                              |
| 8 match op                                     |
| 9 "*" => print(val1 * val2)                    |
| 10 "+" => print(val1 + val2)                   |
| 11 "-" => print(val1 - val2)                   |
| 12 "/" => print(val1 / val2)                   |
| 13 "**" => print(val1 ** val2)                 |
| 14 _ => print(f"unknown op: {op}")             |
| 15 catch                                       |
| 16 print("that's not a number")                |

| 1 # run with `path/to/bog path/here.bog arg1 arg2 "foo"`   |
|:-----------------------------------------------------------|
| 2 let {print} = import "std.io"                            |
| 3 print(import "args")                                     |

| 1 let mut sum = 0            |
|:-----------------------------|
| 2 for let c in "hellö wörld" |
| 3 match c                    |
| 4 "h" => sum += 1            |
| 5 "e" => sum += 2            |
| 6 "l" => sum += 3            |
| 7 "ö" => sum += 4            |
| 8 "w" => sum += 5            |
| 9 "d" => sum += 6            |
| 10                           |
| 11 return sum # 31           |

| 1 let getSome = fn(val) if (val != 0) val - 1   |
|:------------------------------------------------|
| 2                                               |
| 3 let mut val = 10                              |
| 4 while let newVal = getSome(val)               |
| 5 val = newVal                                  |
| 6 return val # 0                                |

Error handling
1 let {input, print} = import "std.io"
2
3 let fails_on_1 = fn(arg) if arg == 1 error(69)
4 let fails_on_2 = fn(arg) if arg == 2 error(42)
5 let fails_on_3 = fn(arg) if arg == 3 error(17)
6
7 let foo = fn(arg)
8 try
9 fails_on_1(arg)
10 fails_on_2(arg)
11 fails_on_3(arg)
12 catch let err
13 return err
14
15 return 99
16
17 print(for let i in 0:4 foo(i)) # [99, 69, 42, 17]
18 print(try fails_on_1(input("give number: ") as int) catch "gave 1")
Destructuring assignment
1 let add = fn ((a,b)) a + b
2 let tuplify = fn (a,b) (a,b)
3 return add(tuplify(1,2)) # 3
Embed
1 const bog = @import("bog");
2
3 var vm = bog.Vm.init(allocator, .{ .import_files = true });
4 defer vm.deinit();
5 try vm.addStd();
6
7 const res = vm.run(source) catch |e| switch (e) {
8 else => |err| return err,
9 error.TokenizeError, error.ParseError, error.CompileError, error.
RuntimeError => {
10 try vm.errors.render(source, out_stream);
11 return error.RunningBogFailed;
12 },
13 };
14
15 const bog_bool = try res.bogToZig(bool, &vm);
3

| 1 let {input, print} = import "std.io"                                 |
|:-----------------------------------------------------------------------|
| 2                                                                      |
| 3 let fails_on_1 = fn(arg) if arg == 1 error(69)                       |
| 4 let fails_on_2 = fn(arg) if arg == 2 error(42)                       |
| 5 let fails_on_3 = fn(arg) if arg == 3 error(17)                       |
| 6                                                                      |
| 7 let foo = fn(arg)                                                    |
| 8 try                                                                  |
| 9 fails_on_1(arg)                                                      |
| 10 fails_on_2(arg)                                                     |
| 11 fails_on_3(arg)                                                     |
| 12 catch let err                                                       |
| 13 return err                                                          |
| 14                                                                     |
| 15 return 99                                                           |
| 16                                                                     |
| 17 print(for let i in 0:4 foo(i)) # [99, 69, 42, 17]                   |
| 18 print(try fails_on_1(input("give number: ") as int) catch "gave 1") |

| 1 let add = fn ((a,b)) a + b   |
|:-------------------------------|
| 2 let tuplify = fn (a,b) (a,b) |
| 3 return add(tuplify(1,2)) # 3 |

| 1 const bog = @import("bog");                                       |
|:--------------------------------------------------------------------|
| 2                                                                   |
| 3 var vm = bog.Vm.init(allocator, .{ .import_files = true });       |
| 4 defer vm.deinit();                                                |
| 5 try vm.addStd();                                                  |
| 6                                                                   |
| 7 const res = vm.run(source) catch |e| switch (e) {                 |
| 8 else => |err| return err,                                         |
| 9 error.TokenizeError, error.ParseError, error.CompileError, error. |
| RuntimeError => {                                                   |
| 10 try vm.errors.render(source, out_stream);                        |
| 11 return error.RunningBogFailed;                                   |
| 12 },                                                               |
| 13 };                                                               |
| 14                                                                  |
| 15 const bog_bool = try res.bogToZig(bool, &vm);                    |

Calling Bog functions from Zig
1 var vm = Vm.init(allocator, .{});
2 defer vm.deinit();
3
4 const res = vm.run(source) catch |e| switch (e) {
5 else => |err| return err,
6 error.TokenizeError, error.ParseError, error.CompileError, error.
RuntimeError => {
7 try vm.errors.render(source, out_stream);
8 return error.RunningBogFailed;
9 },
10 };
11
12 const call_res = vm.call(res, "bogFunction", .{1, true}) catch |e|
switch (e) {
13 else => |err| return err,
14 error.TokenizeError, error.ParseError, error.CompileError, error.
RuntimeError => {
15 try vm.errors.render(source, out_stream);
16 return error.CallingBogFunctionFailed;
17 },
18 };
19
20 const bog_integer = try call_res.bogToZig(i64, &vm);
Calling Zig functions from Bog
1 const my_lib = struct {
2 pub fn pow(val: i64) i64 {
3 return val * val;
4 }
5 };
6
7 var vm = Vm.init(allocator, .{});
8 defer vm.deinit();
9 try vm.addPackage("my_lib", my_lib);
10
11 const res = vm.run(source) catch |e| switch (e) {
12 else => |err| return err,
13 error.TokenizeError, error.ParseError, error.CompileError, error.
RuntimeError => {
14 try vm.errors.render(source, out_stream);
15 return error.RunningBogFailed;
16 },
17 };
18
19 const bog_integer = try res.bogToZig(i64, &vm);
4

| 1 var vm = Vm.init(allocator, .{});                                   |
|:----------------------------------------------------------------------|
| 2 defer vm.deinit();                                                  |
| 3                                                                     |
| 4 const res = vm.run(source) catch |e| switch (e) {                   |
| 5 else => |err| return err,                                           |
| 6 error.TokenizeError, error.ParseError, error.CompileError, error.   |
| RuntimeError => {                                                     |
| 7 try vm.errors.render(source, out_stream);                           |
| 8 return error.RunningBogFailed;                                      |
| 9 },                                                                  |
| 10 };                                                                 |
| 11                                                                    |
| 12 const call_res = vm.call(res, "bogFunction", .{1, true}) catch |e| |
| switch (e) {                                                          |
| 13 else => |err| return err,                                          |
| 14 error.TokenizeError, error.ParseError, error.CompileError, error.  |
| RuntimeError => {                                                     |
| 15 try vm.errors.render(source, out_stream);                          |
| 16 return error.CallingBogFunctionFailed;                             |
| 17 },                                                                 |
| 18 };                                                                 |
| 19                                                                    |
| 20 const bog_integer = try call_res.bogToZig(i64, &vm);               |

| 1 const my_lib = struct {                                            |
|:---------------------------------------------------------------------|
| 2 pub fn pow(val: i64) i64 {                                         |
| 3 return val * val;                                                  |
| 4 }                                                                  |
| 5 };                                                                 |
| 6                                                                    |
| 7 var vm = Vm.init(allocator, .{});                                  |
| 8 defer vm.deinit();                                                 |
| 9 try vm.addPackage("my_lib", my_lib);                               |
| 10                                                                   |
| 11 const res = vm.run(source) catch |e| switch (e) {                 |
| 12 else => |err| return err,                                         |
| 13 error.TokenizeError, error.ParseError, error.CompileError, error. |
| RuntimeError => {                                                    |
| 14 try vm.errors.render(source, out_stream);                         |
| 15 return error.RunningBogFailed;                                    |
| 16 },                                                                |
| 17 };                                                                |
| 18                                                                   |
| 19 const bog_integer = try res.bogToZig(i64, &vm);                   |

20 std.debug.assert(bog_integer == 8);
1 let {pow} = import "my_lib"
2
3 return 2 * pow(2)
Setup
• Download master version of Zig from https://ziglang.org/download/
• Clone this repo
• Build with zig build
• Run with ./zig-cache/bin/bog
5

| 1 let {pow} = import "my_lib"   |
|:--------------------------------|
| 2                               |
| 3 return 2 * pow(2)             |