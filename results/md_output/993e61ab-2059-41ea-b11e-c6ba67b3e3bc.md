Telemetry
Documentation
Telemetry is a lightweight library for dynamic dispatching of events, with a focus on metrics and in‑
strumentation. Any Erlang or Elixir library can use telemetry to emit events. Application code and
other libraries can then hook into those events and run custom handlers.
Note: this library is agnostic to tooling and therefore is not directly related to OpenTelemetry.
For OpenTelemetry in the Erlang VM, see opentelemetry‑erlang, and check openteleme‑
try_telemetry to connect both libraries.
Usage
In a nutshell, you register a custom module and function to be invoked for certain events, which are
executedwheneverthereissuchanevent. Theeventnameisalistofatoms. Eacheventiscomposed
of a numeric value and can have metadata attached to it. Let’s look at an example.
Imagine that you have a web application and you’d like to log latency and response status for each
incoming request. With Telemetry, you can build a module which does exactly that whenever a re‑
sponse is sent. The first step is to execute a measurement.
In Elixir:
1 :telemetry.execute(
2 [:web, :request, :done],
3 %{latency: latency},
4 %{request_path: path, status_code: status}
5 )
In Erlang:
1 telemetry:execute(
2 [web, request, done],
3 #{latency => Latency},
4 #{request_path => Path, status_code => Status}
5 )
Then you can create a module to be invoked whenever the event happens.
In Elixir:
1 defmodule LogResponseHandler do
2 require Logger
1

| 1 :telemetry.execute(                        |
|:---------------------------------------------|
| 2 [:web, :request, :done],                   |
| 3 %{latency: latency},                       |
| 4 %{request_path: path, status_code: status} |
| 5 )                                          |

| 1 telemetry:execute(                             |
|:-------------------------------------------------|
| 2 [web, request, done],                          |
| 3 #{latency => Latency},                         |
| 4 #{request_path => Path, status_code => Status} |
| 5 )                                              |

| 1 defmodule LogResponseHandler do   |
|:------------------------------------|
| 2 require Logger                    |

3
4 def handle_event([:web, :request, :done], measurements, metadata,
_config) do
5 Logger.info(
6 "[#{metadata.request_path}] #{metadata.status_code} sent in #{
measurements.latency}"
7 )
8 end
9 end
In Erlang:
1 -module(log_response_handler).
2
3 -include_lib("kernel/include/logger.hrl").
4
5 handle_event([web, request, done], #{latency := Latency}, #{
request_path := Path,
6 status_code
:=
Status},
_Config
) ->
7 ?LOG_INFO("[~s] ~p sent in ~p", [Path, Status, Latency]).
Important note:
The handle_event callback of each handler is invoked synchronously on each telemetry:
execute call. Therefore, it is extremely important to avoid blocking operations. If you need to
perform any action that is not immediate, consider offloading the work to a separate process (or a
pool of processes) by sending a message.
Finally, all you need to do is to attach the module to the executed event.
In Elixir:
1 :ok =
2 :telemetry.attach(
3 # unique handler id
4 "log-response-handler",
5 [:web, :request, :done],
6 &LogResponseHandler.handle_event/4,
7 nil
8 )
In Erlang:
1 ok = telemetry:attach(
2 %% unique handler id
3 <<"log-response-handler">>,
2

| 3                                                                   |
|:--------------------------------------------------------------------|
| 4 def handle_event([:web, :request, :done], measurements, metadata, |
| _config) do                                                         |
| 5 Logger.info(                                                      |
| 6 "[#{metadata.request_path}] #{metadata.status_code} sent in #{    |
| measurements.latency}"                                              |
| 7 )                                                                 |
| 8 end                                                               |
| 9 end                                                               |

| 1 -module(log_response_handler).                               |
|:---------------------------------------------------------------|
| 2                                                              |
| 3 -include_lib("kernel/include/logger.hrl").                   |
| 4                                                              |
| 5 handle_event([web, request, done], #{latency := Latency}, #{ |
| request_path := Path,                                          |
| 6 status_code                                                  |
| :=                                                             |
| Status},                                                       |
| _Config                                                        |
| ) ->                                                           |
| 7 ?LOG_INFO("[~s] ~p sent in ~p", [Path, Status, Latency]).    |

| 1 :ok =                               |
|:--------------------------------------|
| 2 :telemetry.attach(                  |
| 3 # unique handler id                 |
| 4 "log-response-handler",             |
| 5 [:web, :request, :done],            |
| 6 &LogResponseHandler.handle_event/4, |
| 7 nil                                 |
| 8 )                                   |

| 1 ok = telemetry:attach(      |
|:------------------------------|
| 2 %% unique handler id        |
| 3 <<"log-response-handler">>, |

4 [web, request, done],
5 fun log_response_handler:handle_event/4,
6 []
7 )
Youmightthinkthatitisn’tveryuseful,becauseyoucouldjustaswellwritealogstatementinsteadof
calling telemetry:execute/3 – and you would be right! But now imagine that each Elixir library
would publish its own set of events with information useful for introspection. Currently each library
rollstheirowninstrumentationlayer–Telemetryaimstoprovideasingleinterfacefortheseusecases
across the whole ecosystem.
Spans
Inordertoprovideuniformeventsthatcapturethestartandendofdiscreteevents,itisrecommended
that you use the telemetry:span/3 call. This function will generate a start event and a stop or
exception event depending on whether the provided function executed successfully or raised an er‑
ror. Under the hood, the telemetry:span/3 function leverages the telemetry:execute/3
function, so all the same usage patterns apply. If an exception does occur, an EventPrefix ++ [
exception] event will be emitted and the caught error will be re‑raised.
The measurements for the EventPrefix ++ [start] event will contain a key called
system_time which is derived by calling erlang:system_time(). For EventPrefix
++ [stop] and EventPrefix ++ [exception] events, the measurements will contain
a key called duration and its value is derived by calling erlang:monotonic_time()-
StartMonotonicTime. All events include a monotonic_time measurement too. All of them
represent time as native units.
To convert the duration from native units you can use:
1 milliseconds = System.convert_time_unit(duration, :native, :millisecond
)
To create span events you would do something like this:
In Elixir:
1 def process_message(message) do
2 start_metadata = %{message: message}
3
4 result =
5 :telemetry.span(
6 [:worker, :processing],
7 start_metadata,
8 fn ->
9 result = ... # Process the message
3

| 4 [web, request, done],                    |
|:-------------------------------------------|
| 5 fun log_response_handler:handle_event/4, |
| 6 []                                       |
| 7 )                                        |

| 1 milliseconds = System.convert_time_unit(duration, :native, :millisecond   |
|:----------------------------------------------------------------------------|
| )                                                                           |

| 1 def process_message(message) do      |
|:---------------------------------------|
| 2 start_metadata = %{message: message} |
| 3                                      |
| 4 result =                             |
| 5 :telemetry.span(                     |
| 6 [:worker, :processing],              |
| 7 start_metadata,                      |
| 8 fn ->                                |
| 9 result = ... # Process the message   |

10 {result, %{metadata: "Information related to the processing of
the message"}}
11 end
12 )
13 end
In Erlang:
1 process_message(Message) ->
2 StartMetadata = #{message => Message},
3 Result = telemetry:span(
4 [worker, processing],
5 StartMetadata,
6 fun() ->
7 Result = % Process the message
8 {Result, #{metadata => "Information related to the processing of
the message"}}
9 end
10 ).
To then attach to the events that telemetry:span/3 emits you would do the following:
In Elixir:
1 :ok =
2 :telemetry.attach_many(
3 "log-response-handler",
4 [
5 [:worker, :processing, :start],
6 [:worker, :processing, :stop],
7 [:worker, :processing, :exception]
8 ],
9 &LogResponseHandler.handle_event/4,
10 nil
11 )
In Erlang:
1 ok = telemetry:attach_many(
2 <<"log-response-handler">>,
3 [
4 [worker, processing, start],
5 [worker, processing, stop],
6 [worker, processing, exception]
7 ],
8 fun log_response_handler:handle_event/4,
9 []
10 )
With the following event handler module defined:
4

| 10 {result, %{metadata: "Information related to the processing of   |
|:--------------------------------------------------------------------|
| the message"}}                                                      |
| 11 end                                                              |
| 12 )                                                                |
| 13 end                                                              |

| 1 process_message(Message) ->                                      |
|:-------------------------------------------------------------------|
| 2 StartMetadata = #{message => Message},                           |
| 3 Result = telemetry:span(                                         |
| 4 [worker, processing],                                            |
| 5 StartMetadata,                                                   |
| 6 fun() ->                                                         |
| 7 Result = % Process the message                                   |
| 8 {Result, #{metadata => "Information related to the processing of |
| the message"}}                                                     |
| 9 end                                                              |
| 10 ).                                                              |

| 1 :ok =                               |
|:--------------------------------------|
| 2 :telemetry.attach_many(             |
| 3 "log-response-handler",             |
| 4 [                                   |
| 5 [:worker, :processing, :start],     |
| 6 [:worker, :processing, :stop],      |
| 7 [:worker, :processing, :exception]  |
| 8 ],                                  |
| 9 &LogResponseHandler.handle_event/4, |
| 10 nil                                |
| 11 )                                  |

| 1 ok = telemetry:attach_many(              |
|:-------------------------------------------|
| 2 <<"log-response-handler">>,              |
| 3 [                                        |
| 4 [worker, processing, start],             |
| 5 [worker, processing, stop],              |
| 6 [worker, processing, exception]          |
| 7 ],                                       |
| 8 fun log_response_handler:handle_event/4, |
| 9 []                                       |
| 10 )                                       |

In Elixir:
1 defmodule LogResponseHandler do
2 require Logger
3
4 def handle_event(event, measurements, metadata, _config) do
5 Logger.info("Event: #{inspect(event)}")
6 Logger.info("Measurements: #{inspect(measurements)}")
7 Logger.info("Metadata: #{inspect(metadata)}")
8 end
9 end
In Erlang:
1 -module(log_response_handler).
2
3 -include_lib("kernel/include/logger.hrl").
4
5 handle_event(Event, Measurements, Metadata, _Config) ->
6 ?LOG_INFO("Event: ~p", [Event]),
7 ?LOG_INFO("Measurements: ~p", [Measurements]),
8 ?LOG_INFO("Metadata: ~p", [Metadata]).
Installation
Telemetry is available on Hex. To install, just add it to your dependencies in mix.exs:
1 defp deps() do
2 [
3 {:telemetry, "~> 1.0"}
4 ]
5 end
or rebar.config:
1 {deps, [{telemetry, "~> 1.0"}]}.
Copyright and License
Copyright (c) 2019 Erlang Ecosystem Foundation and Erlang Solutions.
Telemetry’s source code is released under the Apache License, Version 2.0.
See the LICENSE and NOTICE files for more information.
5

| 1 defmodule LogResponseHandler do                             |
|:--------------------------------------------------------------|
| 2 require Logger                                              |
| 3                                                             |
| 4 def handle_event(event, measurements, metadata, _config) do |
| 5 Logger.info("Event: #{inspect(event)}")                     |
| 6 Logger.info("Measurements: #{inspect(measurements)}")       |
| 7 Logger.info("Metadata: #{inspect(metadata)}")               |
| 8 end                                                         |
| 9 end                                                         |

| 1 -module(log_response_handler).                          |
|:----------------------------------------------------------|
| 2                                                         |
| 3 -include_lib("kernel/include/logger.hrl").              |
| 4                                                         |
| 5 handle_event(Event, Measurements, Metadata, _Config) -> |
| 6 ?LOG_INFO("Event: ~p", [Event]),                        |
| 7 ?LOG_INFO("Measurements: ~p", [Measurements]),          |
| 8 ?LOG_INFO("Metadata: ~p", [Metadata]).                  |

| 1 defp deps() do         |
|:-------------------------|
| 2 [                      |
| 3 {:telemetry, "~> 1.0"} |
| 4 ]                      |
| 5 end                    |