postcss‑bem‑linter
A PostCSS plugin to lint BEM‑style CSS.
BEM‑style describes CSS that follows a more‑or‑less strict set of conventions determining what selec‑
tors can be used. Typically, these conventions require that classes begin with the name of the com‑
ponent (or “block”) that contains them, and that all characters after the component name follow a
specified pattern. Original BEM methodology refers to “blocks”, “elements”, and “modifiers”; SUIT
refers to “components”, “descendants”, and “modifiers”. You might have your own terms for similar
concepts.
With this plugin, you can check the validity of selectors against a set of BEM‑style conventions.
You can use preset patterns (SUIT and BEM, currently) or insert your own. The plugin will register
warnings if it finds CSS that does not follow the specified conventions.
Installation
1 npm install postcss postcss-bem-linter --save-dev
Version 1.0.0+ is compatible with PostCSS 5+. (Earlier versions are compatible with PostCSS 4.)
This plugin registers warnings via PostCSS. Therefore, you’ll want to use it with a PostCSS runner that
printswarnings(e.g.gulp-postcss)oranotherPostCSSpluginthatprintswarnings(e.g.postcss
-reporter).
Throughout this document, terms like “selector”, “selector sequence”, and “simple selector”
are used according to the definitions in the Selectors Level 3 spec.
stylelint plugin
postcss‑bem‑linter can also be used as a stylelint plugin: stylelint‑selector‑bem‑pattern.
Byusingthestylelintplugin,allofyourlintingcanhappeninonestep,seamlessly: postcss‑bem‑linter
warnings will output alongside other stylelint warnings. Also, you can take advantage of all the other
features that stylelint offers, such as a CLI and Node.js API, different formatters for output, etc.
Conformance tests
Default mode:
1

• Only allow selector sequences that match the defined convention.
• Only allow custom‑property names that begin with the defined ComponentName.
Weak mode:
• While initial selector sequences (before combinators) must match the defined convention, se‑
quences after combinators are not held to any standard.
Prior to 0.5.0, this plugin checked two other details: that :root rules only contain custom‑properties;
andthatthe:rootselectorisnotgroupedorcombinedwithotherselectors. Thesecheckscannowbe
performedby stylelint. So from0.5.0 onwards, this plugin leaves that business to stylelint to focuson its
more unique task.
Use
1 bemLinter([pattern[, options]])
Defining your pattern
Patterns consist of regular expressions, and functions that return regular expressions, or strings,
which describe valid selector sequences.
Keep in mind: ‑ Patterns describe sequences, not just simple selectors. So if, for example, you
would like to be able to chain state classes to your component classes, as in .Component.is-
open,yourpatternneedstoallowforthischaining. ‑Pseudo‑classesandpseudo‑elementswillbe
ignored if they occur at the end of the sequence. Instead of .Component:first-child.is-
open, you should use .Component.is-open:first-child. The former will trigger a warning
unless you’ve written a silly complicated pattern.
Preset Patterns The following preset patterns are available:
• 'suit' (default), as defined here. Options:
– namespace: a namespace to prefix valid classes, as described in the SUIT docs
• 'bem', as defined here.
– namespace: a namespace to prefix valid classes, to be separated from the block name
with a hyphen, e.g. with namespace foo, .foo-dropdown__menu.
2

You can use a preset pattern and its options in two ways: ‑ Pass the preset’s name as the first
argument, and, if needed, an options object as the second, e.g. bemLinter('suit', {
namespace: 'twt'}). ‑ Pass an object as the first and only argument, with the preset’s name as
the preset property and, if needed, presetOptions, e.g. bemLinter({ preset: 'suit'
, presetOptions: { namespace: 'twt'}).
'suit' is the default pattern; so if you do not pass any pattern argument, SUIT conventions
will be enforced.
Custom Patterns You can define a custom pattern by passing as your first and only argument an
object with the following properties:
componentName default: /^[-_a-zA-Z0-9]+$/
Describes valid component names in one of the following forms:
• A regular expression.
• A string that provides a valid pattern for the RegExp() constructor.
componentSelectors Describes all valid selector sequences for the stylesheet in one of the fol‑
lowing forms:
• A single function that accepts a component name and returns a regular expression, e.g.
1 componentSelectors(componentName) {
2 return new RegExp('^\\.ns-' + componentName + '(?:-[a-zA-Z]+)?$');
3 }
• A single string that provides a valid pattern for the RegExp() constructor when {
componentName} is interpolated with the defined component’s name, e.g.
1 componentSelectors: '^\\.ns-{componentName}(?:-[a-zA-Z]+)?$'
• An object consisting of two properties, initial and combined. Both properties accept the
sametwoformsdescribedabove: afunctionacceptingacomponentnameandreturningareg‑
ularexpression;orastring,interpolatingthecomponentnamewith{componentName},that
will provide a valid pattern for the RegExp() constructor.
initial describes valid initial selector sequences — those occurring at the beginning of a se‑
lector, before any combinators.
combineddescribesvalidselectorsequencesallowedaftercombinators. Twoimportantnotes
about combined:
3

| 1 componentSelectors(componentName) {                                |
|:---------------------------------------------------------------------|
| 2 return new RegExp('^\\.ns-' + componentName + '(?:-[a-zA-Z]+)?$'); |
| 3 }                                                                  |

– If you do not specify a combined pattern, it is assumed that combined sequences must
match the same pattern as initial sequences.
– In weak mode, any combined sequences are accepted, even if you have a combined pat‑
tern.
utilitySelectors Describesvalidutilityselectorsequences. Thiswillbeusedifthestylesheet
defines a group of utilities, as explained below. Can take one of the following forms:
• A regular expression.
• A string that provides a valid pattern for the RegExp() constructor.
ignoreSelectors Describes selector sequences to ignore. You can use this to systematically
ignore selectors matching certain patterns, instead of having to add a /*postcss-bem-linter:
ignore */ comment above each one (see below). Can take one of the following forms:
• A regular expression.
• An array of regular expressions.
• A string that provides a valid pattern for the RegExp() constructor.
• An array of such string patterns.
ignoreCustomProperties Describes custom properties to ignore. Works the same as
ignoreSelectors, above, so please read about that.
Overriding Presets
You can also choose a preset to start with and override specific parts of it, specific patterns.
For example, if you want to use SUIT’s preset generally but write your own utilitySelectors
pattern, you can do that with a config object like this:
1 {
2 preset: 'suit',
3 utilitySelectors: /^\.fancyUtilities-[a-z]+$/
4 }
Examples
Given all of the above, you might call the plugin in any of the following ways:
4

| 1 {                                             |
|:------------------------------------------------|
| 2 preset: 'suit',                               |
| 3 utilitySelectors: /^\.fancyUtilities-[a-z]+$/ |
| 4 }                                             |

1 // use 'suit' conventions
2 bemLinter();
3 bemLinter('suit');
4 bemLinter('suit', { namespace: 'twt' });
5 bemLinter({ preset: 'suit', presetOptions: { namespace: 'twt' }});
6
7 // use 'bem' conventions
8 bemLinter('bem');
9 bemLinter('bem', { namespace: 'ydx' });
10 bemLinter({ preset: 'bem', presetOptions: { namespace: 'ydx' }});
11
12 // define a pattern for component names
13 bemLinter({
14 componentName: /^[A-Z]+$/
15 });
16 bemLinter({
17 componentName: '^[A-Z]+$'
18 });
19
20 // define a single pattern for all selector sequences, initial or
combined
21 bemLinter({
22 componentSelectors(componentName) {
23 return new RegExp('^\\.' + componentName + '(?:-[a-z]+)?$');
24 }
25 });
26 bemLinter({
27 componentSelectors: '^\\.{componentName}(?:-[a-z]+)?$'
28 });
29
30 // define separate `componentName`, `initial`, `combined`, and `
utilities` patterns
31 bemLinter({
32 componentName: /^[A-Z]+$/,
33 componentSelectors: {
34 initial(componentName) {
35 return new RegExp('^\\.' + componentName + '(?:-[a-z]+)?$');
36 },
37 combined(componentName) {
38 return new RegExp('^\\.combined-' + componentName + '-[a-z]+$');
39 }
40 },
41 utilitySelectors: /^\.util-[a-z]+$/
42 });
43 bemLinter({
44 componentName: '^[A-Z]+$',
45 componentSelectors: {
46 initial: '^\\.{componentName}(?:-[a-z]+)?$',
47 combined: '^\\.combined-{componentName}-[a-z]+$'
48 },
5

| 1 // use 'suit' conventions                                          |
|:---------------------------------------------------------------------|
| 2 bemLinter();                                                       |
| 3 bemLinter('suit');                                                 |
| 4 bemLinter('suit', { namespace: 'twt' });                           |
| 5 bemLinter({ preset: 'suit', presetOptions: { namespace: 'twt' }}); |
| 6                                                                    |
| 7 // use 'bem' conventions                                           |
| 8 bemLinter('bem');                                                  |
| 9 bemLinter('bem', { namespace: 'ydx' });                            |
| 10 bemLinter({ preset: 'bem', presetOptions: { namespace: 'ydx' }}); |
| 11                                                                   |
| 12 // define a pattern for component names                           |
| 13 bemLinter({                                                       |
| 14 componentName: /^[A-Z]+$/                                         |
| 15 });                                                               |
| 16 bemLinter({                                                       |
| 17 componentName: '^[A-Z]+$'                                         |
| 18 });                                                               |
| 19                                                                   |
| 20 // define a single pattern for all selector sequences, initial or |
| combined                                                             |
| 21 bemLinter({                                                       |
| 22 componentSelectors(componentName) {                               |
| 23 return new RegExp('^\\.' + componentName + '(?:-[a-z]+)?$');      |
| 24 }                                                                 |
| 25 });                                                               |
| 26 bemLinter({                                                       |
| 27 componentSelectors: '^\\.{componentName}(?:-[a-z]+)?$'            |
| 28 });                                                               |
| 29                                                                   |
| 30 // define separate `componentName`, `initial`, `combined`, and `  |
| utilities` patterns                                                  |
| 31 bemLinter({                                                       |
| 32 componentName: /^[A-Z]+$/,                                        |
| 33 componentSelectors: {                                             |
| 34 initial(componentName) {                                          |
| 35 return new RegExp('^\\.' + componentName + '(?:-[a-z]+)?$');      |
| 36 },                                                                |
| 37 combined(componentName) {                                         |
| 38 return new RegExp('^\\.combined-' + componentName + '-[a-z]+$');  |
| 39 }                                                                 |
| 40 },                                                                |
| 41 utilitySelectors: /^\.util-[a-z]+$/                               |
| 42 });                                                               |
| 43 bemLinter({                                                       |
| 44 componentName: '^[A-Z]+$',                                        |
| 45 componentSelectors: {                                             |
| 46 initial: '^\\.{componentName}(?:-[a-z]+)?$',                      |
| 47 combined: '^\\.combined-{componentName}-[a-z]+$'                  |
| 48 },                                                                |

49 utilitySelectors: '^\.util-[a-z]+$'
50 });
51
52 // start with the `bem` preset but include a special `componentName`
pattern
53 // and `ignoreSelectors` pattern to ignore Modernizr-injected `no-*`
classes
54 bemLinter({
55 preset: 'bem',
56 componentName: /^cmpnt_[a-zA-Z]+$/,
57 ignoreSelectors: /^\.no-.+$/
58 });
59 bemLinter({
60 preset: 'bem',
61 componentName: '^cmpnt_[a-zA-Z]+$',
62 ignoreSelectors: '^\.no-.+$'
63 });
64
65 // ... using an array for `ignoreSelectors`
66 bemLinter({
67 preset: 'bem',
68 componentName: /^cmpnt_[a-zA-Z]+$/,
69 ignoreSelectors: [
70 /^\.no-.+$/,
71 /^\.isok-.+$/
72 ]
73 });
74 bemLinter({
75 preset: 'bem',
76 componentName: '^cmpnt_[a-zA-Z]+$',
77 ignoreSelectors: [
78 '^\.no-.+$',
79 '^\.isok-.+$'
80 ]
81 });
Defining a component and utilities
The plugin will only lint the CSS if it knows the context of the CSS: is it a utility or a component. To de‑
finethecontext,usetheconfigurationoptionstodefineitbasedonthefilename(css/components
/*.css)oruseaspecialcommenttodefinecontextfortheCSSafterit. Whendefiningacomponent,
the component name is needed.
Definecomponentsandutilitiesimplicitlybasedontheirfilename Whendefiningacomponent
base on the filename, the name of the file (minus the extension) will be used implicitly as the compo‑
nent name for linting. The configuration option for implicit components take:
6

| 49 utilitySelectors: '^\.util-[a-z]+$'                                  |
|:------------------------------------------------------------------------|
| 50 });                                                                  |
| 51                                                                      |
| 52 // start with the `bem` preset but include a special `componentName` |
| pattern                                                                 |
| 53 // and `ignoreSelectors` pattern to ignore Modernizr-injected `no-*` |
| classes                                                                 |
| 54 bemLinter({                                                          |
| 55 preset: 'bem',                                                       |
| 56 componentName: /^cmpnt_[a-zA-Z]+$/,                                  |
| 57 ignoreSelectors: /^\.no-.+$/                                         |
| 58 });                                                                  |
| 59 bemLinter({                                                          |
| 60 preset: 'bem',                                                       |
| 61 componentName: '^cmpnt_[a-zA-Z]+$',                                  |
| 62 ignoreSelectors: '^\.no-.+$'                                         |
| 63 });                                                                  |
| 64                                                                      |
| 65 // ... using an array for `ignoreSelectors`                          |
| 66 bemLinter({                                                          |
| 67 preset: 'bem',                                                       |
| 68 componentName: /^cmpnt_[a-zA-Z]+$/,                                  |
| 69 ignoreSelectors: [                                                   |
| 70 /^\.no-.+$/,                                                         |
| 71 /^\.isok-.+$/                                                        |
| 72 ]                                                                    |
| 73 });                                                                  |
| 74 bemLinter({                                                          |
| 75 preset: 'bem',                                                       |
| 76 componentName: '^cmpnt_[a-zA-Z]+$',                                  |
| 77 ignoreSelectors: [                                                   |
| 78 '^\.no-.+$',                                                         |
| 79 '^\.isok-.+$'                                                        |
| 80 ]                                                                    |
| 81 });                                                                  |

• Enable it for all files: implicitComponents: true
• Enable it for files that match a glob pattern: implicitComponents: 'components
/**/*.css'
• Enable it for files that match one of multiple glob patterns: implicitComponents: ['
components/**/*.css', 'others/**/*.css']
TheCSSwillimplicitlybelintedasutilitiesinfilesmarkedassuchbytheirfilename. Theconfiguration
option for implicit utilities take:
• Enable it for files that match a glob pattern: implicitUtilities: 'utils/*.css'
• Enableitforfilesthatmatchoneofmultipleglobpatterns: implicitUtilities: ['util
/*.css', 'bar/**/*.css']
Definecomponents/utilitieswith a comment Thesecommentdefinitions canbe providedin two
syntaxes: concise and verbose.
• Concise definition syntax: /** @define ComponentName */ or /** @define
utilities */
• Verbosedefinitionsyntax: /*postcss-bem-linter: define ComponentName */or
/*postcss-bem-linter: define utilities */.
Weak mode is turned on by adding ; weak to a definition, e.g. /** @define ComponentName
; weak */ or /*postcss-bem-linter: define ComponentName; weak */.
Concise syntax:
1 /** @define MyComponent */
2
3 :root {
4 --MyComponent-property: value;
5 }
6
7 .MyComponent {}
8
9 .MyComponent-other {}
Verbose syntax:
1 /** postcss-bem-linter: define FancyComponent */
2
3 :root {
4 --FancyComponent-property: value;
5 }
6
7 .FancyComponent {}
7

| 1 /** @define MyComponent */     |
|:---------------------------------|
| 2                                |
| 3 :root {                        |
| 4 --MyComponent-property: value; |
| 5 }                              |
| 6                                |
| 7 .MyComponent {}                |
| 8                                |
| 9 .MyComponent-other {}          |

| 1 /** postcss-bem-linter: define FancyComponent */   |
|:-----------------------------------------------------|
| 2                                                    |
| 3 :root {                                            |
| 4 --FancyComponent-property: value;                  |
| 5 }                                                  |
| 6                                                    |
| 7 .FancyComponent {}                                 |

8
9 .FancyComponent-other {}
Weak mode:
1 /** @define MyComponent; weak */
2
3 :root {
4 --MyComponent-property: value;
5 }
6
7 .MyComponent {}
8
9 .MyComponent .other {}
Implicit:
1 bemLinter({
2 preset: 'bem',
3 implicitComponents: 'components/**/*.css',
4 implicitUtilities: 'utils/*.css'
5 });
Utilities:
1 /** @define utilities */
2
3 .u-sizeFill {}
4
5 .u-sm-horse {}
If a component is defined and the component name does not match your componentName pattern,
the plugin will throw an error.
Multiple definitions
It’s recommended that you keep each defined group of rules in a distinct file, with the definition at
the top of the file. If, however, you have a good reason for multiple definitions within a single file, you
can do that.
Successive definitions override each other. So the following works:
1 /** @define Foo */
2 .Foo {}
3
4 /** @define Bar */
5 .Bar {}
6
8

| 8                          |
|:---------------------------|
| 9 .FancyComponent-other {} |

| 1 /** @define MyComponent; weak */   |
|:-------------------------------------|
| 2                                    |
| 3 :root {                            |
| 4 --MyComponent-property: value;     |
| 5 }                                  |
| 6                                    |
| 7 .MyComponent {}                    |
| 8                                    |
| 9 .MyComponent .other {}             |

| 1 bemLinter({                                |
|:---------------------------------------------|
| 2 preset: 'bem',                             |
| 3 implicitComponents: 'components/**/*.css', |
| 4 implicitUtilities: 'utils/*.css'           |
| 5 });                                        |

| 1 /** @define utilities */   |
|:-----------------------------|
| 2                            |
| 3 .u-sizeFill {}             |
| 4                            |
| 5 .u-sm-horse {}             |

| 1 /** @define Foo */   |
|:-----------------------|
| 2 .Foo {}              |
| 3                      |
| 4 /** @define Bar */   |
| 5 .Bar {}              |
| 6                      |

7 /** @define utilities */
8 .u-something {}
You can also deliberately end the enforcement of a definition with the following special comments:
/** @end */ or /*postcss-bem-linter: end */.
1 /** @define Foo */
2 .Foo {}
3 /** @end */
4
5 .something-something-something {}
One use‑case for this functionality is when linting files after concatenation performed by a CSS pro‑
cessor like Less or Sass, whose syntax is not always compatible with PostCSS. See issue #57.
Ignoring specific selectors
If you need to ignore a specific selector but do not want to ignore the entire stylesheet or end the
enforcement of a definition, there are two ways to accomplish this:
As describe above, you can include an ignoreSelectors regular expression (or array of regular
expressions) in your configuration. This is the best approach if you want to systematically ignore all
selectors matching a pattern (e.g. all Modernizr classes).
If you just want to ignore a single, isolated selector, though, you can do so by preceding the selector
with this comment: /*postcss-bem-linter: ignore */.
1 /** @define MyComponent */
2
3 .MyComponent {
4 display: flex;
5 }
6
7 /* postcss-bem-linter: ignore */
8 .no-flexbox .Component {
9 display: block;
10 }
The comment will cause the linter to ignore only the very next selector.
Testing CSS files
Pass your individual CSS files through the plugin. It will register warnings for conformance failures,
which you can print to the console using postcss-reporter or relying on a PostCSS runner (such
as gulp-postcss).
9

| 7 /** @define utilities */   |
|:-----------------------------|
| 8 .u-something {}            |

| 1 /** @define Foo */                |
|:------------------------------------|
| 2 .Foo {}                           |
| 3 /** @end */                       |
| 4                                   |
| 5 .something-something-something {} |

| 1 /** @define MyComponent */       |
|:-----------------------------------|
| 2                                  |
| 3 .MyComponent {                   |
| 4 display: flex;                   |
| 5 }                                |
| 6                                  |
| 7 /* postcss-bem-linter: ignore */ |
| 8 .no-flexbox .Component {         |
| 9 display: block;                  |
| 10 }                               |

1 const postcss = require('postcss');
2 const bemLinter = require('postcss-bem-linter');
3 const reporter = require('postcss-reporter');
4
5 files.forEach(file => {
6 const css = fs.readFileSync(file, 'utf-8');
7 postcss()
8 .use(bemLinter())
9 .use(reporter())
10 .process(css)
11 .then(result => { .. });
12 });
Contributing
Please note that this project is released with a Contributor Code of Conduct. By participating in this
project you agree to abide by its terms.
Development
Install dependencies. Requires Yarn 1.x (Classic)
1 yarn
Run the tests.
1 yarn test
Watch and automatically re‑run the unit tests.
1 yarn start
10

| 1 const postcss = require('postcss');              |
|:---------------------------------------------------|
| 2 const bemLinter = require('postcss-bem-linter'); |
| 3 const reporter = require('postcss-reporter');    |
| 4                                                  |
| 5 files.forEach(file => {                          |
| 6 const css = fs.readFileSync(file, 'utf-8');      |
| 7 postcss()                                        |
| 8 .use(bemLinter())                                |
| 9 .use(reporter())                                 |
| 10 .process(css)                                   |
| 11 .then(result => { .. });                        |
| 12 });                                             |