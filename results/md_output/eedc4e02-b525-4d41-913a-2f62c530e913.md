Acts As List
Build Status
ANNOUNCING: Positioning, the gem
AsmaintainerofbothActsAsListandtheRankedModelgems,I’vebecomeintimatelyaquaintedwith
the strengths and weaknesses of each. I ended up writing a small scale Rails Concern for positioning
database rows for a recent project and it worked really well so I’ve decided to release it as a gem:
Positioning
Positioning works similarly to Acts As List in that it maintains a sequential list of integer values as
positions. It differs in that it encourages a unique constraints on the position column and supports
multiple lists per database table. It borrows Ranked Model’s concept of relative positioning. I encour‑
age you to check it out and give it a whirl on your project!
Description
Thisacts_asextensionprovidesthecapabilitiesforsortingandreorderinganumberofobjectsina
list. The class that has this specified needs to have a position column defined as an integer on the
mapped database table.
0.8.0 Upgrade Notes
There are a couple of changes of behaviour from 0.8.0 onwards:
• If you specify add_new_at: :top, new items will be added to the top of the list like always.
But now, if you specify a position at insert time: .create(position: 3), the position will
be respected. In this example, the item will end up at position 3 and will move other items
further down the list. Before 0.8.0 the position would be ignored and the item would still be
added to the top of the list. #220
• acts_as_list now copes with disparate position integers (i.e. gaps between the numbers).
There has been a change in behaviour for the higher_items method. It now returns items
withthefirstiteminthecollectionbeingtheclosestitemtothereferenceitem,andthelastitem
inthecollectionbeingthefurthestfromthereferenceitem(a.k.a. thefirstiteminthelist). #223
1

Installation
In your Gemfile:
1 gem 'acts_as_list'
Or, from the command line:
1 gem install acts_as_list
Example
At first, you need to add a position column to desired table:
1 rails g migration AddPositionToTodoItem position:integer
2 rake db:migrate
After that you can use acts_as_list method in the model:
1 class TodoList < ActiveRecord::Base
2 has_many :todo_items, -> { order(position: :asc) }
3 end
4
5 class TodoItem < ActiveRecord::Base
6 belongs_to :todo_list
7 acts_as_list scope: :todo_list
8 end
9
10 todo_list = TodoList.find(...)
11 todo_list.todo_items.first.move_to_bottom
12 todo_list.todo_items.last.move_higher
Instance Methods Added To ActiveRecord Models
You’ll have a number of methods added to each instance of the ActiveRecord model that to which
acts_as_list is added.
In acts_as_list, “higher” means further up the list (a lower position), and “lower” means fur‑
ther down the list (a higher position). That can be confusing, so it might make sense to add tests
that validate that you’re using the right method given your context.
Methods That Change Position and Reorder List
• list_item.insert_at(2)
2

| 1 rails g migration AddPositionToTodoItem position:integer   |
|:-------------------------------------------------------------|
| 2 rake db:migrate                                            |

| 1 class TodoList < ActiveRecord::Base                |
|:-----------------------------------------------------|
| 2 has_many :todo_items, -> { order(position: :asc) } |
| 3 end                                                |
| 4                                                    |
| 5 class TodoItem < ActiveRecord::Base                |
| 6 belongs_to :todo_list                              |
| 7 acts_as_list scope: :todo_list                     |
| 8 end                                                |
| 9                                                    |
| 10 todo_list = TodoList.find(...)                    |
| 11 todo_list.todo_items.first.move_to_bottom         |
| 12 todo_list.todo_items.last.move_higher             |

• list_item.move_lower will do nothing if the item is the lowest item
• list_item.move_higher will do nothing if the item is the highest item
• list_item.move_to_bottom
• list_item.move_to_top
• list_item.remove_from_list
Methods That Change Position Without Reordering List
• list_item.increment_position
• list_item.decrement_position
• list_item.set_list_position(3)
Methods That Return Attributes of the Item’s List Position
• list_item.first?
• list_item.last?
• list_item.in_list?
• list_item.not_in_list?
• list_item.default_position?
• list_item.higher_item
• list_item.higher_items will return all the items above list_item in the list (ordered
by the position, ascending)
• list_item.lower_item
• list_item.lower_items will return all the items below list_item in the list (ordered
by the position, ascending)
Adding acts_as_list To An Existing Model
Asitstandsacts_as_listrequirespositionvaluestobesetonthemodelbeforetheinstancemeth‑
ods above will work. Adding something like the below to your migration will set the default position.
Change the parameters to order if you want a different initial ordering.
1 class AddPositionToTodoItem < ActiveRecord::Migration
2 def change
3 add_column :todo_items, :position, :integer
4 TodoItem.order(:updated_at).each.with_index(1) do |todo_item, index
|
5 todo_item.update_column :position, index
6 end
3

| 1 class AddPositionToTodoItem < ActiveRecord::Migration               |
|:----------------------------------------------------------------------|
| 2 def change                                                          |
| 3 add_column :todo_items, :position, :integer                         |
| 4 TodoItem.order(:updated_at).each.with_index(1) do |todo_item, index |
| |                                                                     |
| 5 todo_item.update_column :position, index                            |
| 6 end                                                                 |

7 end
8 end
If you are using the scope option things can get a bit more complicated. Let’s say you have
acts_as_list scope: :todo_list, you might instead need something like this:
1 TodoList.all.each do |todo_list|
2 todo_list.todo_items.order(:updated_at).each.with_index(1) do |
todo_item, index|
3 todo_item.update_column :position, index
4 end
5 end
When using PostgreSQL, it is also possible to leave this migration up to the database layer. Inside of
the change block you could write:
1 execute <<~SQL.squish
2 UPDATE todo_items
3 SET position = mapping.new_position
4 FROM (
5 SELECT
6 id,
7 ROW_NUMBER() OVER (
8 PARTITION BY todo_list_id
9 ORDER BY updated_at
10 ) AS new_position
11 FROM todo_items
12 ) AS mapping
13 WHERE todo_items.id = mapping.id;
14 SQL
Notes
All position queries (select, update, etc.) inside gem methods are executed without the default
scope(i.e.Model.unscoped),thiswillpreventnastyissueswhenthedefaultscopeisdifferentfrom
acts_as_list scope.
The position column is set after validations are called, so you should not put a presence valida‑
tion on the position column.
If you need a scope by a non‑association field you should pass an array, containing field name, to a
scope:
1 class TodoItem < ActiveRecord::Base
2 # `task_category` is a plain text field (e.g. 'work', 'shopping', '
meeting'), not an association
3 acts_as_list scope: [:task_category]
4

| 7 end   |
|:--------|
| 8 end   |

| 1 TodoList.all.each do |todo_list|                                |
|:------------------------------------------------------------------|
| 2 todo_list.todo_items.order(:updated_at).each.with_index(1) do | |
| todo_item, index|                                                 |
| 3 todo_item.update_column :position, index                        |
| 4 end                                                             |
| 5 end                                                             |

| 1 execute <<~SQL.squish               |
|:--------------------------------------|
| 2 UPDATE todo_items                   |
| 3 SET position = mapping.new_position |
| 4 FROM (                              |
| 5 SELECT                              |
| 6 id,                                 |
| 7 ROW_NUMBER() OVER (                 |
| 8 PARTITION BY todo_list_id           |
| 9 ORDER BY updated_at                 |
| 10 ) AS new_position                  |
| 11 FROM todo_items                    |
| 12 ) AS mapping                       |
| 13 WHERE todo_items.id = mapping.id;  |
| 14 SQL                                |

| 1 class TodoItem < ActiveRecord::Base                                 |
|:----------------------------------------------------------------------|
| 2 # `task_category` is a plain text field (e.g. 'work', 'shopping', ' |
| meeting'), not an association                                         |
| 3 acts_as_list scope: [:task_category]                                |

4 end
You can also add multiple scopes in this fashion:
1 class TodoItem < ActiveRecord::Base
2 belongs_to :todo_list
3 acts_as_list scope: [:task_category, :todo_list_id]
4 end
Furthermore, you can optionally include a hash of fixed parameters that will be included in all
queries:
1 class TodoItem < ActiveRecord::Base
2 belongs_to :todo_list
3 # or `discarded_at` if using discard
4 acts_as_list scope: [:task_category, :todo_list_id, deleted_at: nil]
5 end
This is useful when using this gem in conjunction with the popular acts_as_paranoid or discard
gems.
More Options
• column default: position. Use this option if the column name in your database is different
from position.
• top_of_list default: 1. Use this option to define the top of the list. Use 0 to make the col‑
lection act more like an array in its indexing.
• add_new_at default: :bottom. Use this option to specify whether objects get added to the
:top or :bottom of the list. nil will result in new items not being added to the list on create,
i.e, position will be kept nil after create.
• touch_on_update default: true. Use touch_on_update: false if you don’t want to
update the timestamps of the associated records.
• sequential_updates Specifies whether insert_at should update objects positions during
shuffling one by one to respect position column unique not null constraint. Defaults to true if
positioncolumnhasuniqueindex,otherwisefalse. Ifconstraintisdeferrable initially
deferred (PostgreSQL), overriding it with false will speed up insert_at.
Disabling temporarily
If you need to temporarily disable acts_as_list during specific operations such as mass‑update
or imports:
5

| 1 class TodoItem < ActiveRecord::Base                 |
|:------------------------------------------------------|
| 2 belongs_to :todo_list                               |
| 3 acts_as_list scope: [:task_category, :todo_list_id] |
| 4 end                                                 |

| 1 class TodoItem < ActiveRecord::Base                                  |
|:-----------------------------------------------------------------------|
| 2 belongs_to :todo_list                                                |
| 3 # or `discarded_at` if using discard                                 |
| 4 acts_as_list scope: [:task_category, :todo_list_id, deleted_at: nil] |
| 5 end                                                                  |

1 TodoItem.acts_as_list_no_update do
2 perform_mass_update
3 end
Inanacts_as_list_no_updateblock,allcallbacksaredisabled,andpositionsarenotupdated.
New records will be created with the default value from the database. It is your responsibility to cor‑
rectly manage positions values.
Youcanalsopassanarrayofclassesasanargumenttodisabledatabaseupdatesonjustthoseclasses.
It can be any ActiveRecord class that has acts_as_list enabled.
1 class TodoList < ActiveRecord::Base
2 has_many :todo_items, -> { order(position: :asc) }
3 acts_as_list
4 end
5
6 class TodoItem < ActiveRecord::Base
7 belongs_to :todo_list
8 has_many :todo_attachments, -> { order(position: :asc) }
9
10 acts_as_list scope: :todo_list
11 end
12
13 class TodoAttachment < ActiveRecord::Base
14 belongs_to :todo_item
15 acts_as_list scope: :todo_item
16 end
17
18 TodoItem.acts_as_list_no_update([TodoAttachment]) do
19 TodoItem.find(10).update(position: 2)
20 TodoAttachment.find(10).update(position: 1)
21 TodoAttachment.find(11).update(position: 2)
22 TodoList.find(2).update(position: 3) # For this instance the
callbacks will be called because we haven't passed the class as an
argument
23 end
Troubleshooting Database Deadlock Errors
When using this gem in an app with a high amount of concurrency, you may see “deadlock” errors
raised by your database server. It’s difficult for the gem to provide a solution that fits every app. Here
are some steps you can take to mitigate and handle these kinds of errors.
6

| 1 TodoItem.acts_as_list_no_update do   |
|:---------------------------------------|
| 2 perform_mass_update                  |
| 3 end                                  |

| 1 class TodoList < ActiveRecord::Base                              |
|:-------------------------------------------------------------------|
| 2 has_many :todo_items, -> { order(position: :asc) }               |
| 3 acts_as_list                                                     |
| 4 end                                                              |
| 5                                                                  |
| 6 class TodoItem < ActiveRecord::Base                              |
| 7 belongs_to :todo_list                                            |
| 8 has_many :todo_attachments, -> { order(position: :asc) }         |
| 9                                                                  |
| 10 acts_as_list scope: :todo_list                                  |
| 11 end                                                             |
| 12                                                                 |
| 13 class TodoAttachment < ActiveRecord::Base                       |
| 14 belongs_to :todo_item                                           |
| 15 acts_as_list scope: :todo_item                                  |
| 16 end                                                             |
| 17                                                                 |
| 18 TodoItem.acts_as_list_no_update([TodoAttachment]) do            |
| 19 TodoItem.find(10).update(position: 2)                           |
| 20 TodoAttachment.find(10).update(position: 1)                     |
| 21 TodoAttachment.find(11).update(position: 2)                     |
| 22 TodoList.find(2).update(position: 3) # For this instance the    |
| callbacks will be called because we haven't passed the class as an |
| argument                                                           |
| 23 end                                                             |

1) Use the Most Concise API
One easy way to reduce deadlocks is to use the most concise gem API available for what you want to
accomplish. In this specific example, the more concise API for creating a list item at a position results
inonetransactioninsteadoftwo,anditissuesfewerSQLstatements. Issuingfewerstatementstends
to lead to faster transactions. Faster transactions are less likely to deadlock.
Example:
1 # Good
2 TodoItem.create(todo_list: todo_list, position: 1)
3
4 # Bad
5 item = TodoItem.create(todo_list: todo_list)
6 item.insert_at(1)
2) Rescue then Retry
Deadlocks are always a possibility when updating tables rows concurrently. The general advice from
MySQL documentation is to catch these errors and simply retry the transaction; it will probably suc‑
ceedonanotherattempt. (seeHowtoMinimizeandHandleDeadlocks)Retryingtransactionssounds
simple, but there are many details that need to be chosen on a per‑app basis: How many retry at‑
tempts should be made? Should there be a wait time between attempts? What other statements
were in the transaction that got rolled back?
Here a simple example of rescuing from deadlock and retrying the operation: * ActiveRecord
::Deadlocked is available in Rails >= 5.1.0. * If you have Rails < 5.1.0, you will need to rescue
ActiveRecord::StatementInvalid and check #cause.
1 attempts_left = 2
2 while attempts_left > 0
3 attempts_left -= 1
4 begin
5 TodoItem.transaction do
6 TodoItem.create(todo_list: todo_list, position: 1)
7 end
8 attempts_left = 0
9 rescue ActiveRecord::Deadlocked
10 raise unless attempts_left > 0
11 end
12 end
YoucanalsousetheapproachsuggestedinthisStackOverflowpost: https://stackoverflow.com/questions/4027659/activerecord3‑
deadlock‑retry
7

| 1 # Good                                             |
|:-----------------------------------------------------|
| 2 TodoItem.create(todo_list: todo_list, position: 1) |
| 3                                                    |
| 4 # Bad                                              |
| 5 item = TodoItem.create(todo_list: todo_list)       |
| 6 item.insert_at(1)                                  |

| 1 attempts_left = 2                                  |
|:-----------------------------------------------------|
| 2 while attempts_left > 0                            |
| 3 attempts_left -= 1                                 |
| 4 begin                                              |
| 5 TodoItem.transaction do                            |
| 6 TodoItem.create(todo_list: todo_list, position: 1) |
| 7 end                                                |
| 8 attempts_left = 0                                  |
| 9 rescue ActiveRecord::Deadlocked                    |
| 10 raise unless attempts_left > 0                    |
| 11 end                                               |
| 12 end                                               |

3) Lock Parent Record
In addition to reacting to deadlocks, it is possible to reduce their frequency with more pessimistic
locking. This approach uses the parent record as a mutex for the entire list. This kind of locking is
very effective at reducing the frequency of deadlocks while updating list items. However, there are
some things to keep in mind: * This locking pattern needs to be used around every call that modifies
the list; even if it does not reorder list items. * This locking pattern effectively serializes operations on
the list. The throughput of operations on the list will decrease. * Locking the parent record may lead
to deadlock elsewhere if some other code also locks the parent table.
Example:
1 todo_list = TodoList.create(name: "The List")
2 todo_list.with_lock do
3 item = TodoItem.create(description: "Buy Groceries", todo_list:
todo_list, position: 1)
4 end
Versions
Version0.9.0addsacts_as_list_no_update(https://github.com/brendon/acts_as_list/pull/244)
andcompatibilitywithnot‑nullanduniquenessconstraintsonthedatabase(https://github.com/brendon/acts_as_list/pull/246).
These additions shouldn’t break compatibility with existing implementations.
As of version 0.7.5 Rails 5 is supported.
All versions 0.1.5 onwards require Rails 3.0.x and higher.
A note about data integrity
We often hear complaints that position values are repeated, incorrect etc. For example, #254. To
ensure data integrity, you should rely on your database. There are two things you can do:
1. Use constraints. If you model Item that belongs_to an Order, and it has a position
column, then add a unique constraint on items with [:order_id, :position]. Think
of it as a list invariant. What are the properties of your list that don’t change no matter how
many items you have in it? One such propery is that each item has a distinct position. Another
could be that position is always greater than 0. It is strongly recommended that you rely on
your database to enforce these invariants or constraints. Here are the docs for PostgreSQL and
MySQL.
8

| 1 todo_list = TodoList.create(name: "The List")                   |
|:------------------------------------------------------------------|
| 2 todo_list.with_lock do                                          |
| 3 item = TodoItem.create(description: "Buy Groceries", todo_list: |
| todo_list, position: 1)                                           |
| 4 end                                                             |

2. Use mutexes or row level locks. At its heart the duplicate problem is that of handling concur‑
rency. Adding a contention resolution mechanism like locks will solve it to some extent. But it
is not a solution or replacement for constraints. Locks are also prone to deadlocks.
As a library, acts_as_list may not always have all the context needed to apply these tools. They
are much better suited at the application level.
Roadmap
1. Sort based feature
Contributing to acts_as_list
• Checkoutthelatestmastertomakesurethefeaturehasn’tbeenimplementedorthebughasn’t
been fixed yet
• Check out the issue tracker to make sure someone already hasn’t requested it and/or
contributed it
• Fork the project
• Start a feature/bugfix branch
• Commit and push until you are happy with your contribution
• Make sureto add tests forit. This is important so I don’t breakit in a futureversionunintention‑
ally.
• PleasetrynottomesswiththeRakefile,version,orhistory. Ifyouwanttohaveyourownversion,
or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry‑pick
around it.
• I would recommend using Rails 3.1.x and higher for testing the build before a pull request. The
current test harness does not quite work with 3.0.x. The plugin itself works, but the issue lies
with testing infrastructure.
Copyright
Copyright (c) 2007 David Heinemeier Hansson, released under the MIT license
9