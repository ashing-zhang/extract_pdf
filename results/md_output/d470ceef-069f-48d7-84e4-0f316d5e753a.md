Reliability of Module Based Software
System
Rudrani Banerjee and Angshuman Sarkar∗
Department of Statistics, Visva-Bharati University, India
7002 tcO 51  ]PA.tats[  1v0472.0170:viXra
October 30, 2018
Abstract
This paper consider the problem of determining the reliability of a software
system which can be decomposed in a number of modules. We have derived the
expression of the reliability of a system using the Markovian model for the transfer
of control between modules in order. We have given the expression of reliability
by considering both benign and catastrophic failure. The expression of reliability
presented in this work is applicable for some control software which are designed
to detect its own internal errors.
1 Introduction
Now a days large scale software systems are used in every walk of life. The price of
software are much higher than the cost of hardware when we consider a huge computer
intensive system. Moreover the penalty cost incurred by a false outcome of a system
is enormous. To address such a challenge posed by this technological trend, during the
last three decades extensive research has focused on the area of software reliability. The
consideration of software reliability is increasing because of the growing emphasis on
software that is reusable (as opposed to software that is written for a terminal mission),
where it is essential to demonstrate that the system will perform reliably for a variety of
end-user applications.
A software system is defined here as a ” collection of programs and system files such
that the system files are accessed and altered only by the programs in the collection ”.
Each element in this collection will be called a module - for instance, a module might be
a program, a subprogram, or a file. The performance ( and hence the reliability ) of the
system clearly depends on that of each individual module and the relationship between
these modules and the system; in this regard a software system is quite similar to any
other system. However, the actual relationship between system and module reliabilities
is quite unique and depends on the specific definition of software reliability as well as on
∗
Email:sangshu 2000@yahoo.com
1

the structure of the overall system. In this paper we focus on software systems that can
be decomposed into a finite number of modules.
In testing a software one may test the system as a whole, but in practice, different
organizational entities are assigned responsibility of developing different modules. So it
will be more beneficial in the context of both cost and time test the individual modules
instead of testing them together. In order to do this, some mathematical models, of-
ten referred to as Software Reliability Growth Models (SRGM) are used to enable the
software reliability practitioners to estimate the expected future reliability of a software
under development and accordingly allocate time, money, human resources to a project.
Often these reliability growth models express software system reliability in terms of the
individual module reliabilities which is favorable under both time and cost constraints.
Cheung (2), first expressed the system reliability in terms of the component relia-
bilities. Poore et al. (1) suggest allocating the targeted system reliability goal among
the components and then testing the individual components to verify whether the com-
ponent reliabilities meet the allocated goals at a specified level of confidence, where as
Easterling, Mazumdar, Spencer and Diegert (6), has discussed this method may lead to
estimates of overly conservative sample size requirements for component testing. Yang
et. al. has implemented the idea of using testability to estimate software reliability.
They have also provided the basic steps involve estimating testability, evaluating how
well software was written, and assessing the relationship between testing and usage by
assuming the modules are independently functioning. They have also compared their
results with those obtained by using two reliability growth models. Rajgopal et. al.
has used a Markovian model for the transfer of control between modules in order to
develop the system reliability expression in terms of the module reliabilities in case of a
dependent setup. They have also discussed a procedure for determining the minimum
number of tests required of each module such that the probability of certifying a system
whose reliability falls below a specified value R is less than a specified small fraction β.
0
Bondavalli et. al. has considered the concept of benign failure and catastrophic failure
for determining the software reliability for a iterative program.
In this paper we have expressed the system reliability in terms of testability of a
particular module following Yang et. al. for dependent modules and have introduced
the concepts of benign and catastrophic failure following Bondavalli et. al. in case of a
system where it can be decomposed in a finite number of dependently functional mod-
ules. The section 2 discuss the notations and preliminaries, section 3 gives the expression
of the probability of correct output for a specific input. Recent research [26] has shown
a strong correlation between reliability and coverage criteria (Lott et al. (2005), Khun
et. al. (2002), Yilmaz et. al. (2004) etc.), although it is very difficult to quantify this
relation. Dalal et al. [6] and many more has examined this relationship between unit-test
statement coverage and system-test faults later attributed to those units.
Present work has been organized in 4 sections the section 2 gives the notation and
preliminaries of software reliability in terms testability of a module. In the 3rd sections
we have derived the probability of correct output of a particular system corresponding
to a particular input considering both the case presence and absence of benign failure.
In Section 4 we present a brief discussions about the procedure mentioned here.
2

2 Notations and Preliminaries
There is no rigorous definition of ’Quality’. But it can be weakly defined as the fit-
ness of purpose of any product to its users. Similarly software quality is defined as
the conformance to explicitly stated functions and performance requirements, explicitly
documented development standards and implicit characteristics that are expected of all
professionally crafted software(Cai Kai-Yuan Cai (3)). Alternatively, the quality of a
software may be characterized by some quality factors of a software - reliability, effi-
ciency, correctness, usability, testability etc.
Reliability of a software system may be viewed as the expected value of probability
of failure-free operation of a program for a randomly chosen set of input variables. The
term failure in the context of software reliability implies a result other than what was
expected from the software for a set of inputs. Following Voas et. al. (1995) we define
the testability of a particular system as the probability of failure of the system for a par-
ticular input when it is assumed that there is at least one fault in the system. Suppose
we have a software system which can be decomposed in N modules. Thus the testability
of a particular module, say ith (∀i = 1(1)N) module, is given by
p = Prob[ that the ith module will give incorrect output | there is at least one fault,
i
probability distribution of input] (1)
The expression for the probability that the ith module will contain error if the module
has tested n times successfully, is given by the following (Yang et. al. (1998))
i
α (0)(1 − p )ni
i i
α (t) = (2)
i
α (0)(1 − p )ni + 1 − α (0)
i i i
where α (0) is the probability of failure of the system before testing. Let π (x) is the
i t
probability of a system giving correct output corresponding to a particular set of input
x. The expression of π (x) by assuming the independent setup is given by (Yang et. al.
t
(1998))
π (x) = (1 − q α (t)) (3)
t i i
Y
i∈S
where q is the revealibility of the i th module and S(x) is the set of those modules which
i
will be executed by the input x. The reliability of a software system is given by
R = π (x)φ(x)dx (4)
t t
Z
x∈X
where X is the set of all possible inputs and φ(x) is the probability distribution of x.
3 Detailed Expression of π (x) for Dependent Setup
t
A software system is necessarily an iterative. In each iteration a particular module
accepts a value and produce an output. The outcomes of an individual iteration may
3

be: i) success, i.e., the delivery of a correct result, ii) a benign failure of the program,
i.e., an output that is not correct but does not, by itself, cause the entire mission of
the controlled system to fail, or iii) a catastrophic failure, i.e., an output that causes
the immediate failure of the entire mission. The characterization of failures in benign
and catastrophic is discussed with example by Bondavalli. et. al. (). In this section
we derive the expression of π (x) first of all only considering the catastrophic failure
t
and then in the subsequent subsection considering the benign and catastrophic failure
simultaneously.
3.1 Expression of π (x): No Benign Failure in the System
t
Consider the above software system with N modules. Let p be the probability that the
ij
control from the ith module will be transferred to the jth module with correct execution
(∀i = 1(1)N, ∀j = 1(1)N). Let S be a state of successful completion of the system.
As S is achievable from any one of the module so we define p (∀i = 1(1)N) as the
iS
probability of successful completion of the mission from the ith module. Here we must
n
have p + p = 1.
iS j=1 ij
As we hPave a faulty system, that is, we have a system where there is at least one
fault or if the faults can be classified into categories then there are at most one fault
of each category. So we introduce another state F, i.e., unsuccessful completion of the
mission. As any module may be faulty so the state F also can be achieved from any of
the module. We define p as the probability of unsuccessful completion of the module i
iF
(∀i = 1(1)N). The transition probability matrix takes the following form for the above
setup.
p (1 − αx(t)) p (1 − αx(t)) ... p (1 − αx(t)) p (1 − αx(t)) αx(t)
11 1 12 1 1N 1 1S 1 1
 p (1 − αx(t)) p (1 − αx(t)) ... p (1 − αx(t)) p (1 − αx(t)) αx(t) 
21 2 22 2 2N 2 2S 2 2
 ... ... ... ... ... ... 
Q =   (5)
 p (1 − αx (t)) p (1 − αx (t)) ... p (1 − αx (t)) p (1 − αx (t)) αx (t) 
 N1 N N2 N NN N NS N N 
 
0 0 ... 0 1 0
 
 
 0 0 ... 0 0 1 
 
where αx(t) is the probability of faulty completion of the ith module for the input x.
i
The expression of αx(t) is given by
i
x
α (t) = q α (t) (6)
i i i
If we assume that the first block is the control block then the probability of correct
completion of the mission for the given input x is given by (Parzen (1962))
N
Qˆ )−1p αx
π (x) = (I − (1 − (t)) (7)
t N 1i iS i
X
i=1
ˆ
where Q is the sub-matrix of Q deleting its last two columns and rows.
4

3.2 Expression of π (x): Benign Failure and Catastrophic Fail-
t
ure are in the System
From the software viewpoint solely, and without referring to any specific application, we
assume here that all detected failures (default safe values of the control outputs from the
computer) do not prevent the mission to continue and are in this sense benign, whereas
undetected failures are conservatively assumed to have a ”catastrophic” effect on the
controlled system. Obviously, if knowledge of the consequences of software failures on
the system was available for a specific system, the proper splitting of software failures
into benign and catastrophic could be precisely made. We make the following assumption
to model the system.
Suppose SS is a state where the total system, that is all the N modules, runs without
any fault of either kind. Let B be the state where the system is running in benign failure
i
of ith level, that is after i iterations the system will enter in the state SS. As the previous
subsection S and F denotes the successful completion of the mission and completion of
the mission with a failure respectively. The mission will fail if their is a catastrophic
failure in the system. Let us also assume that if there is a benign failure of length greater
than a threshold value, say n , then the system will enter in a catastrophic failure region.
c
Although this assumption will take the model a little away from reality, a model should
be good enough to handle a benign failure of any arbitrary random length, but this
assumption will make the calculation of reliability expression easier which will increase
its practical application. At this point note that the state S, that is the successful
completion of the program, can be achieved only from the state SS, where as the state
F can be achieved from any of the state SS or B ’s (∀i = 1(1)N), but we assume here
i
the control will be transferred from the state B to B only to reduce the number of
i i−1
parameters in the model.
The transition probability matrix will be as follows
Q Qb Qb ... Qb Qb Qb S0 F0
00 01 02 0(nc−2) 0(nc−1) 0nc
 Qb O O ... O O O ¯ 0 ¯ 0 
10
 O Qb O ... O O O ¯ 0 ¯ 0 
 21 
 ... ... ... ... ... ... ... ... ... 
 
Q = (8)
 O O O ... Qb O O ¯ 0 ¯ 0 
 
(nc−1)(nc−2)
 
 O O O ... O Qb O ¯ 0 ¯ 0 
 nc(nc−1) 
 ¯′ ¯′ ¯′ ¯′ ¯′ ¯′ 
 0 0 0 ... 0 0 0 1 0 
 
 ¯ 0′ ¯ 0′ ¯ 0′ ... ¯ 0′ ¯ 0′ ¯ 0′ 0 1 
 
Here the matrix Q is a N ×N matrix which describes that the flow is running without
00
entering in benign failure or catastrophic failure. The matrix Qb is also a N ×N matrix
0k
giving the transition probabilities of the flow of control from stable state to the kth level
benign failure (∀k = 1(1)n ). Similarly, the matrix Qb which is also N × N denotes the
c kl
transition probabilities of the control entering from the kth level benign failure to l th
level (∀k = 1(1)n ∀l = 1(1)n ). From the kth level benign failure we can only achieve
c c
the k − 1th level benign failure so Qb = O (∀l 6= k − 1). Where O is the null matrix of
kl
order N ×N. S0 is a N ×1 vector of the transition probabilities of successful completion
of the mission from the stable state. As the mission can terminate successfully only from
5

¯
the stable state so the rest of the entries in this column are all zero. 0 denotes a null
vector of length N and ¯ 0′ denotes transpose of ¯ 0. Finally, F0 is a column vector of length
N giving probabilities of reaching the state of catastrophic failure from the stable state.
To give the structure of sub-matrices Q , let us define pSS be the probability of the
00 ij
control to enter from the ith module to jth module in the state SS. So the matrix Q
00
is given by
pSS pSS ... pSS
11 12 1N
 pSS pSS ... pSS 
Q = 21 22 2N (9)
00
... ... ... ...
 
 
 pSS pSS ... pSS 
 N1 N2 NN 
Let us also define pSB be the probability that the control will be transferred from the
ij
module i to the module j from the state SS to any of benign failure. Let also pB the
k
probability that the control will enter in B , thus the probability that the control will
k
enter in the jth module from the ith module in the state B is given by pSBpB. So the
k ij k
matrix Qb will take the following form
0k
pSBpB pSBpB ... pSBpB
11 k 12 k 1N k
 pSBpB pSBpB ... pSBpB 
Qb = 21 k 22 k 2N k (10)
0k ... ... ... ...
 
 
 pSBpB pSBpB ... pSB pB 
 N1 k N2 k NN k 
If p and p is respectively the successful completion of the mission and achieving
iS iF
catastrophic failure from the ith module. Then we must have
N nc N
SS B SB
p + p p + p + p = 1 ∀i = 1(1)N (11)
ij k ij iS iF
X X X
j=1 k=1 j=1
The matrix Qb takes the following form
kk−1
pbb pbb ... pbb
11 12 1N
 pbb pbb ... pbb 
Qb = 21 22 2N (12)
kk−1
... ... ... ...
 
 
 pbb pbb ... pbb 
 N1 N2 NN 
Here we have
N
bb
p = 1 ∀i = 1(1)N (13)
ij
X
j=1
Finally, the matrix Qb is the matrix of transition probabilities, say pbS, that the flow of
10 ij
control will be transferred from the ith to the jth module and from the B to SS. Here
1
also
N
bS
p = 1 ∀i = 1(1)N (14)
ij
X
j=1
6

By assuming as before the first module as the control module the expression of π (x) is
t
given
N
Qˆ )−1p
π (x) = (I − (15)
t Nnc 1i iS
X
i=1
ˆ
where Q is once again the sub-matrix of Q deleting its last two columns and rows.
4 Conclusions
In this work we have given an expression of the reliability of a software system which can
be divided in a finite number of modules. The transition probabilities we have considered
can be easily estimated using maximum likelihood method of estimation.
Consider the setup without benign failure, suppose ith block is tested n times, out of
i
which xi times the control is transferred to the jth state (∀i = 1(1)N&∀j = 1(1)N, S, F).
j
The maximum likelihood estimates of p is xi/( N xi +xi ) and that of αx(t) is xi /n .
ij j i=1 j S i F i
Hence estimate of π (x) can be obtained and lPet it be denoted by πˆ (x). Finally the
t t
estimate of reliability of a system can be given by
1
ˆ
R = πˆ (x) (16)
t t
|W|
X
x∈W
where W is the set of all inputs which are used for testing. This is an extension of some
previous work and the model what we have considered are more realistic for some control
software which are designed to detect its own internal errors and then issue a safe output
and reset itself to a known state from which the program is likely to proceed correctly.
References
[1] A.Bertolino and L.Strigini (1996). On The Use of Testability Measures for Depend-
ability Assessment. IEEE Trans on Software Engineering 22(2):97-108.
[2] C. Beightler and D.T. Phillips (1976). Applied Geometric Programming. John Wiley
& Sons,Inc., New York.
[3] E.Cinlar (1975). Introduction to Stochastic Processes. Prentice-Hall, Inc., Engle-
wood Clios, N.J.
[4] E.C.Soistman and K.B.Ragsdale (1984). Combined Hardware/Software Reliability
Prediction Methodology. Rome Air Development Center Contract Report OR. 18 -
173, Vol.2.
[5] E.Parzen. (1962), Stochastic Processes, Holden-Day, San Francisco, Calif.
[6] J.H.Poore, H.D.Mills and D.Mutchler (1993). Planning and Certifying Software Sys-
tem Reliability. IEEE Software, 88-99.
7

[7] J.M.Voas and K.W.Miller (1995). Software Testability: The new verification. IEEE
Software. 17-28.
[8] J.Rajgopal and D.L.Bricker (1995). An Algorithm for Solving The Polynomial GP
Problem, Based on Generalized Programming. Department of Industrial Engineer-
ing, University of Pittsburgh, Technical Report No.TR95-10.
[9] J.Rajgopal and M.Mazumdar (1995). Designing Component Test Plans for Series
System Reliability via Mathematical Programming. Technometrics 37,195-212.
[10] J.Rajgopal and M.Mazumdar (1997). Minimum Cost Component Test Plans for
evaluating Reliability of a Highly Reliable Parallel System. Naval Research Logistics
44, 401-418.
[11] K.S.Al-Sultan, M.F.Hussain and J.S.Nizami (1996). A Genetic Algorithm for The
Set Covering Problem. The Journal of the Operational Research Soc. 47, 5, 702-709.
[12] K.Siegrist(1998). Reliability of Systems with Markov Transfer of Control. IEEE
Transaction on Software Engineering 14, 1049-1053.
[13] K.W.Miller, L.J.Morrel, R.E.Noonan, S.K.Park, D.M.Nicol, B.M.Murril and
J.M.Voas (1992) Estimating the probability of failure when testing reveals no failure.
IEEE Trans. on Software Engineering 18(1): 33-43.
[14] Mark C.K. Yang, W.Eric Wong, Alberto Pasquini (1998). Applying Testability to
Reliability Estimation, Proc. of IEEE International Symposium on Software Relia-
bility Engineering, Puderborn 90-99.
[15] M.Avriel,R.S.Dembo and U.Plassy (1975). Solution of Generalized Geometric Pro-
grams. International Journal for Numerical methods in Engineering 9, 149-168.
[16] R.C.Cheung (1980). A User-Oriented Reliability Model. IEEE Trans. Software En-
gineering, SE- 6(2): 118-125.
[17] R.C.Easterling, M.Mazumdar, F.W.Spencer and K.V.Diegert (1991). System Based
Component Test Plan and Operating Characteristics: Binomial Data Technometrics
33,287- 298.
[18] S.Gal (1974). Optimal Test Design for Reliability Demonstration. Operational Re-
search 22, 1236-1242.
[19] S.Ghosh, A.P.Mathur, J.R.Horgan, J.J.Li, W.E.Wong(1997). Software Fault Injec-
tion Testing on a Distributed System - A Case Study, Proc. of the 1st International
Quality Week Europe, Brussels, Belgium.
[20] S.Wolfram(1996). The Mathematics Book (3rd edition). Cambridge University Press
and Wolfram Media, Inc.Champaign, 3.
[21] W.Kuo (1992). Software Reliability. Maynards Industrial Engineering Handbook,
4th edition(W.K.Hodson, Editor-in-Chief), 11116-11122.
8

[22] W.Eric Wong, J.R.Horgan, S.London and Aditya P.Mathur (1998). Effect of test set
minimization on Fault Detection Effectiveness. Software-Practice and Experience,
28(4): 347-369.
9